"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8589],{3905:function(e,t,a){a.d(t,{Zo:function(){return d},kt:function(){return N}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},d=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},k=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),k=p(a),N=r,c=k["".concat(s,".").concat(N)]||k[N]||m[N]||l;return a?n.createElement(c,i(i({ref:t},d),{},{components:a})):n.createElement(c,i({ref:t},d))}));function N(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=k;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var p=2;p<l;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}k.displayName="MDXCreateElement"},7188:function(e,t,a){a.r(t),a.d(t,{assets:function(){return d},contentTitle:function(){return s},default:function(){return N},frontMatter:function(){return o},metadata:function(){return p},toc:function(){return m}});var n=a(7462),r=a(3366),l=(a(7294),a(3905)),i=["components"],o={},s="IAsset",p={unversionedId:"protocol/smart-contract-api/pcv/balancer/IVault",id:"protocol/smart-contract-api/pcv/balancer/IVault",title:"IAsset",description:"Full external interface for the Vault core contract - no external or public methods exist in the contract that",source:"@site/docs/protocol/smart-contract-api/pcv/balancer/IVault.md",sourceDirName:"protocol/smart-contract-api/pcv/balancer",slug:"/protocol/smart-contract-api/pcv/balancer/IVault",permalink:"/docs/protocol/smart-contract-api/pcv/balancer/IVault",editUrl:"https://github.com/fei-protocol/docs/tree/gh-pages/docs/protocol/smart-contract-api/pcv/balancer/IVault.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"IMerkleOrchard",permalink:"/docs/protocol/smart-contract-api/pcv/balancer/IMerkleOrchard"},next:{title:"IWeightedPool",permalink:"/docs/protocol/smart-contract-api/pcv/balancer/IWeightedPool"}},d={},m=[{value:"Functions",id:"functions",level:2},{value:"hasApprovedRelayer",id:"hasapprovedrelayer",level:3},{value:"Parameters",id:"parameters",level:4},{value:"setRelayerApproval",id:"setrelayerapproval",level:3},{value:"Parameters",id:"parameters-1",level:4},{value:"getInternalBalance",id:"getinternalbalance",level:3},{value:"Parameters",id:"parameters-2",level:4},{value:"manageUserBalance",id:"manageuserbalance",level:3},{value:"Parameters",id:"parameters-3",level:4},{value:"registerPool",id:"registerpool",level:3},{value:"Parameters",id:"parameters-4",level:4},{value:"getPool",id:"getpool",level:3},{value:"Parameters",id:"parameters-5",level:4},{value:"registerTokens",id:"registertokens",level:3},{value:"Parameters",id:"parameters-6",level:4},{value:"deregisterTokens",id:"deregistertokens",level:3},{value:"Parameters",id:"parameters-7",level:4},{value:"getPoolTokenInfo",id:"getpooltokeninfo",level:3},{value:"Parameters",id:"parameters-8",level:4},{value:"getPoolTokens",id:"getpooltokens",level:3},{value:"Parameters",id:"parameters-9",level:4},{value:"joinPool",id:"joinpool",level:3},{value:"Parameters",id:"parameters-10",level:4},{value:"exitPool",id:"exitpool",level:3},{value:"Parameters",id:"parameters-11",level:4},{value:"swap",id:"swap",level:3},{value:"Parameters",id:"parameters-12",level:4},{value:"batchSwap",id:"batchswap",level:3},{value:"Parameters",id:"parameters-13",level:4},{value:"queryBatchSwap",id:"querybatchswap",level:3},{value:"Parameters",id:"parameters-14",level:4},{value:"managePoolBalance",id:"managepoolbalance",level:3},{value:"Parameters",id:"parameters-15",level:4},{value:"setPaused",id:"setpaused",level:3},{value:"Parameters",id:"parameters-16",level:4},{value:"Events",id:"events",level:2},{value:"RelayerApprovalChanged",id:"relayerapprovalchanged",level:3},{value:"Parameters",id:"parameters-17",level:4},{value:"InternalBalanceChanged",id:"internalbalancechanged",level:3},{value:"Parameters",id:"parameters-18",level:4},{value:"ExternalBalanceTransfer",id:"externalbalancetransfer",level:3},{value:"Parameters",id:"parameters-19",level:4},{value:"PoolRegistered",id:"poolregistered",level:3},{value:"Parameters",id:"parameters-20",level:4},{value:"TokensRegistered",id:"tokensregistered",level:3},{value:"Parameters",id:"parameters-21",level:4},{value:"TokensDeregistered",id:"tokensderegistered",level:3},{value:"Parameters",id:"parameters-22",level:4},{value:"PoolBalanceChanged",id:"poolbalancechanged",level:3},{value:"Parameters",id:"parameters-23",level:4},{value:"Swap",id:"swap-1",level:3},{value:"Parameters",id:"parameters-24",level:4},{value:"PoolBalanceManaged",id:"poolbalancemanaged",level:3},{value:"Parameters",id:"parameters-25",level:4}],k={toc:m};function N(e){var t=e.components,a=(0,r.Z)(e,i);return(0,l.kt)("wrapper",(0,n.Z)({},k,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"iasset"},"IAsset"),(0,l.kt)("h1",{id:"ivault"},"IVault"),(0,l.kt)("p",null,"Full external interface for the Vault core contract - no external or public methods exist in the contract that\ndon't override one of these declarations."),(0,l.kt)("h2",{id:"functions"},"Functions"),(0,l.kt)("h3",{id:"hasapprovedrelayer"},"hasApprovedRelayer"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function hasApprovedRelayer(\n    address user,\n    address relayer\n) external returns (bool)\n")),(0,l.kt)("p",null,"Returns true if ",(0,l.kt)("inlineCode",{parentName:"p"},"user")," has approved ",(0,l.kt)("inlineCode",{parentName:"p"},"relayer")," to act as a relayer for them."),(0,l.kt)("h4",{id:"parameters"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"user")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"relayer")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"})))),(0,l.kt)("h3",{id:"setrelayerapproval"},"setRelayerApproval"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function setRelayerApproval(\n    address sender,\n    address relayer,\n    bool approved\n) external\n")),(0,l.kt)("p",null,"Allows ",(0,l.kt)("inlineCode",{parentName:"p"},"relayer")," to act as a relayer for ",(0,l.kt)("inlineCode",{parentName:"p"},"sender")," if ",(0,l.kt)("inlineCode",{parentName:"p"},"approved")," is true, and disallows it otherwise."),(0,l.kt)("p",null,"Emits a ",(0,l.kt)("inlineCode",{parentName:"p"},"RelayerApprovalChanged")," event."),(0,l.kt)("h4",{id:"parameters-1"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"sender")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"relayer")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"approved")),(0,l.kt)("td",{parentName:"tr",align:"left"},"bool"),(0,l.kt)("td",{parentName:"tr",align:"left"})))),(0,l.kt)("h3",{id:"getinternalbalance"},"getInternalBalance"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function getInternalBalance(\n    address user,\n    contract IERC20[] tokens\n) external returns (uint256[])\n")),(0,l.kt)("p",null,"Returns ",(0,l.kt)("inlineCode",{parentName:"p"},"user"),"'s Internal Balance for a set of tokens."),(0,l.kt)("h4",{id:"parameters-2"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"user")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"tokens")),(0,l.kt)("td",{parentName:"tr",align:"left"},"contract IERC20[]"),(0,l.kt)("td",{parentName:"tr",align:"left"})))),(0,l.kt)("h3",{id:"manageuserbalance"},"manageUserBalance"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function manageUserBalance(\n    struct IVault.UserBalanceOp[] ops\n) external\n")),(0,l.kt)("p",null,"Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\nand plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as\nit lets integrators reuse a user's Vault allowance."),(0,l.kt)("p",null,"For each operation, if the caller is not ",(0,l.kt)("inlineCode",{parentName:"p"},"sender"),", it must be an authorized relayer for them."),(0,l.kt)("h4",{id:"parameters-3"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"ops")),(0,l.kt)("td",{parentName:"tr",align:"left"},"struct IVault.UserBalanceOp[]"),(0,l.kt)("td",{parentName:"tr",align:"left"})))),(0,l.kt)("h3",{id:"registerpool"},"registerPool"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function registerPool(\n    enum IVault.PoolSpecialization specialization\n) external returns (bytes32)\n")),(0,l.kt)("p",null,"Registers the caller account as a Pool with a given specialization setting. Returns the Pool's ID, which\nis used in all Pool-related functions. Pools cannot be deregistered, nor can the Pool's specialization be\nchanged."),(0,l.kt)("p",null,"The caller is expected to be a smart contract that implements either ",(0,l.kt)("inlineCode",{parentName:"p"},"IGeneralPool")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"IMinimalSwapInfoPool"),",\ndepending on the chosen specialization setting. This contract is known as the Pool's contract."),(0,l.kt)("p",null,"Note that the same contract may register itself as multiple Pools with unique Pool IDs, or in other words,\nmultiple Pools may share the same contract."),(0,l.kt)("p",null,"Emits a ",(0,l.kt)("inlineCode",{parentName:"p"},"PoolRegistered")," event."),(0,l.kt)("h4",{id:"parameters-4"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"specialization")),(0,l.kt)("td",{parentName:"tr",align:"left"},"enum IVault.PoolSpecialization"),(0,l.kt)("td",{parentName:"tr",align:"left"})))),(0,l.kt)("h3",{id:"getpool"},"getPool"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function getPool(\n    bytes32 poolId\n) external returns (address, enum IVault.PoolSpecialization)\n")),(0,l.kt)("p",null,"Returns a Pool's contract address and specialization setting."),(0,l.kt)("h4",{id:"parameters-5"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"poolId")),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes32"),(0,l.kt)("td",{parentName:"tr",align:"left"})))),(0,l.kt)("h3",{id:"registertokens"},"registerTokens"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function registerTokens(\n    bytes32 poolId,\n    contract IERC20[] tokens,\n    address[] assetManagers\n) external\n")),(0,l.kt)("p",null,"Registers ",(0,l.kt)("inlineCode",{parentName:"p"},"tokens")," for the ",(0,l.kt)("inlineCode",{parentName:"p"},"poolId")," Pool. Must be called by the Pool's contract."),(0,l.kt)("p",null,"Pools can only interact with tokens they have registered. Users join a Pool by transferring registered tokens,\nexit by receiving registered tokens, and can only swap registered tokens."),(0,l.kt)("p",null,"Each token can only be registered once. For Pools with the Two Token specialization, ",(0,l.kt)("inlineCode",{parentName:"p"},"tokens")," must have a length\nof two, that is, both tokens must be registered in the same ",(0,l.kt)("inlineCode",{parentName:"p"},"registerTokens")," call, and they must be sorted in\nascending order."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"tokens")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"assetManagers")," arrays must have the same length, and each entry in these indicates the Asset\nManager for the corresponding token. Asset Managers can manage a Pool's tokens via ",(0,l.kt)("inlineCode",{parentName:"p"},"managePoolBalance"),",\ndepositing and withdrawing them directly, and can even set their balance to arbitrary amounts. They are therefore\nexpected to be highly secured smart contracts with sound design principles, and the decision to register an\nAsset Manager should not be made lightly."),(0,l.kt)("p",null,"Pools can choose not to assign an Asset Manager to a given token by passing in the zero address. Once an Asset\nManager is set, it cannot be changed except by deregistering the associated token and registering again with a\ndifferent Asset Manager."),(0,l.kt)("p",null,"Emits a ",(0,l.kt)("inlineCode",{parentName:"p"},"TokensRegistered")," event."),(0,l.kt)("h4",{id:"parameters-6"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"poolId")),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes32"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"tokens")),(0,l.kt)("td",{parentName:"tr",align:"left"},"contract IERC20[]"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"assetManagers")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address[]"),(0,l.kt)("td",{parentName:"tr",align:"left"})))),(0,l.kt)("h3",{id:"deregistertokens"},"deregisterTokens"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function deregisterTokens(\n    bytes32 poolId,\n    contract IERC20[] tokens\n) external\n")),(0,l.kt)("p",null,"Deregisters ",(0,l.kt)("inlineCode",{parentName:"p"},"tokens")," for the ",(0,l.kt)("inlineCode",{parentName:"p"},"poolId")," Pool. Must be called by the Pool's contract."),(0,l.kt)("p",null,"Only registered tokens (via ",(0,l.kt)("inlineCode",{parentName:"p"},"registerTokens"),") can be deregistered. Additionally, they must have zero total\nbalance. For Pools with the Two Token specialization, ",(0,l.kt)("inlineCode",{parentName:"p"},"tokens")," must have a length of two, that is, both tokens\nmust be deregistered in the same ",(0,l.kt)("inlineCode",{parentName:"p"},"deregisterTokens")," call."),(0,l.kt)("p",null,"A deregistered token can be re-registered later on, possibly with a different Asset Manager."),(0,l.kt)("p",null,"Emits a ",(0,l.kt)("inlineCode",{parentName:"p"},"TokensDeregistered")," event."),(0,l.kt)("h4",{id:"parameters-7"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"poolId")),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes32"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"tokens")),(0,l.kt)("td",{parentName:"tr",align:"left"},"contract IERC20[]"),(0,l.kt)("td",{parentName:"tr",align:"left"})))),(0,l.kt)("h3",{id:"getpooltokeninfo"},"getPoolTokenInfo"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function getPoolTokenInfo(\n    bytes32 poolId,\n    contract IERC20 token\n) external returns (uint256 cash, uint256 managed, uint256 lastChangeBlock, address assetManager)\n")),(0,l.kt)("p",null,"Returns detailed information for a Pool's registered token."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"cash")," is the number of tokens the Vault currently holds for the Pool. ",(0,l.kt)("inlineCode",{parentName:"p"},"managed")," is the number of tokens\nwithdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for ",(0,l.kt)("inlineCode",{parentName:"p"},"token"),"\nequals the sum of ",(0,l.kt)("inlineCode",{parentName:"p"},"cash")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"managed"),"."),(0,l.kt)("p",null,"Internally, ",(0,l.kt)("inlineCode",{parentName:"p"},"cash")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"managed")," are stored using 112 bits. No action can ever cause a Pool's token ",(0,l.kt)("inlineCode",{parentName:"p"},"cash"),",\n",(0,l.kt)("inlineCode",{parentName:"p"},"managed")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"total")," balance to be greater than 2^112 - 1."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"lastChangeBlock")," is the number of the block in which ",(0,l.kt)("inlineCode",{parentName:"p"},"token"),"'s total balance was last modified (via either a\njoin, exit, swap, or Asset Manager update). This value is useful to avoid so-called 'sandwich attacks', for\nexample when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a\nchange for this purpose, and will update ",(0,l.kt)("inlineCode",{parentName:"p"},"lastChangeBlock"),"."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"assetManager")," is the Pool's token Asset Manager."),(0,l.kt)("h4",{id:"parameters-8"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"poolId")),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes32"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"token")),(0,l.kt)("td",{parentName:"tr",align:"left"},"contract IERC20"),(0,l.kt)("td",{parentName:"tr",align:"left"})))),(0,l.kt)("h3",{id:"getpooltokens"},"getPoolTokens"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function getPoolTokens(\n    bytes32 poolId\n) external returns (contract IERC20[] tokens, uint256[] balances, uint256 lastChangeBlock)\n")),(0,l.kt)("p",null,"Returns a Pool's registered tokens, the total balance for each, and the latest block when ",(0,l.kt)("em",{parentName:"p"},"any")," of\nthe tokens' ",(0,l.kt)("inlineCode",{parentName:"p"},"balances")," changed."),(0,l.kt)("p",null,"The order of the ",(0,l.kt)("inlineCode",{parentName:"p"},"tokens")," array is the same order that will be used in ",(0,l.kt)("inlineCode",{parentName:"p"},"joinPool"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"exitPool"),", as well as in all\nPool hooks (where applicable). Calls to ",(0,l.kt)("inlineCode",{parentName:"p"},"registerTokens")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"deregisterTokens")," may change this order."),(0,l.kt)("p",null,"If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\norder as passed to ",(0,l.kt)("inlineCode",{parentName:"p"},"registerTokens"),"."),(0,l.kt)("p",null,"Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\nthe amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use ",(0,l.kt)("inlineCode",{parentName:"p"},"getPoolTokenInfo"),"\ninstead."),(0,l.kt)("h4",{id:"parameters-9"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"poolId")),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes32"),(0,l.kt)("td",{parentName:"tr",align:"left"})))),(0,l.kt)("h3",{id:"joinpool"},"joinPool"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function joinPool(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    struct IVault.JoinPoolRequest request\n) external\n")),(0,l.kt)("p",null,"Called by users to join a Pool, which transfers tokens from ",(0,l.kt)("inlineCode",{parentName:"p"},"sender")," into the Pool's balance. This will\ntrigger custom Pool behavior, which will typically grant something in return to ",(0,l.kt)("inlineCode",{parentName:"p"},"recipient")," - often tokenized\nPool shares."),(0,l.kt)("p",null,"If the caller is not ",(0,l.kt)("inlineCode",{parentName:"p"},"sender"),", it must be an authorized relayer for them."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"assets")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"maxAmountsIn")," arrays must have the same length, and each entry indicates the maximum amount\nto send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\nthese maximums."),(0,l.kt)("p",null,"If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\nthis mechanism, the IAsset sentinel value (the zero address) must be passed in the ",(0,l.kt)("inlineCode",{parentName:"p"},"assets")," array instead of the\nWETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\nback to the caller (not the sender, which is important for relayers)."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"assets")," must have the same length and order as the array returned by ",(0,l.kt)("inlineCode",{parentName:"p"},"getPoolTokens"),". This prevents issues when\ninteracting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\nsorted ",(0,l.kt)("em",{parentName:"p"},"before")," replacing the WETH address with the ETH sentinel value (the zero address), which means the final\n",(0,l.kt)("inlineCode",{parentName:"p"},"assets")," array might not be sorted. Pools with no registered tokens cannot be joined."),(0,l.kt)("p",null,"If ",(0,l.kt)("inlineCode",{parentName:"p"},"fromInternalBalance")," is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\nbe made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\nwithdrawn from Internal Balance: attempting to do so will trigger a revert."),(0,l.kt)("p",null,"This causes the Vault to call the ",(0,l.kt)("inlineCode",{parentName:"p"},"IBasePool.onJoinPool")," hook on the Pool's contract, where Pools implement\ntheir own custom logic. This typically requires additional information from the user (such as the expected number\nof Pool shares). This can be encoded in the ",(0,l.kt)("inlineCode",{parentName:"p"},"userData")," argument, which is ignored by the Vault and passed\ndirectly to the Pool's contract, as is ",(0,l.kt)("inlineCode",{parentName:"p"},"recipient"),"."),(0,l.kt)("p",null,"Emits a ",(0,l.kt)("inlineCode",{parentName:"p"},"PoolBalanceChanged")," event."),(0,l.kt)("h4",{id:"parameters-10"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"poolId")),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes32"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"sender")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"recipient")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"request")),(0,l.kt)("td",{parentName:"tr",align:"left"},"struct IVault.JoinPoolRequest"),(0,l.kt)("td",{parentName:"tr",align:"left"})))),(0,l.kt)("h3",{id:"exitpool"},"exitPool"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function exitPool(\n    bytes32 poolId,\n    address sender,\n    address payable recipient,\n    struct IVault.ExitPoolRequest request\n) external\n")),(0,l.kt)("p",null,"Called by users to exit a Pool, which transfers tokens from the Pool's balance to ",(0,l.kt)("inlineCode",{parentName:"p"},"recipient"),". This will\ntrigger custom Pool behavior, which will typically ask for something in return from ",(0,l.kt)("inlineCode",{parentName:"p"},"sender")," - often tokenized\nPool shares. The amount of tokens that can be withdrawn is limited by the Pool's ",(0,l.kt)("inlineCode",{parentName:"p"},"cash")," balance (see\n",(0,l.kt)("inlineCode",{parentName:"p"},"getPoolTokenInfo"),")."),(0,l.kt)("p",null,"If the caller is not ",(0,l.kt)("inlineCode",{parentName:"p"},"sender"),", it must be an authorized relayer for them."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"tokens")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"minAmountsOut")," arrays must have the same length, and each entry in these indicates the minimum\ntoken amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\nit just enforces these minimums."),(0,l.kt)("p",null,"If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\nenable this mechanism, the IAsset sentinel value (the zero address) must be passed in the ",(0,l.kt)("inlineCode",{parentName:"p"},"assets")," array instead\nof the WETH address. Note that it is not possible to combine ETH and WETH in the same exit."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"assets")," must have the same length and order as the array returned by ",(0,l.kt)("inlineCode",{parentName:"p"},"getPoolTokens"),". This prevents issues when\ninteracting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\nbe sorted ",(0,l.kt)("em",{parentName:"p"},"before")," replacing the WETH address with the ETH sentinel value (the zero address), which means the\nfinal ",(0,l.kt)("inlineCode",{parentName:"p"},"assets")," array might not be sorted. Pools with no registered tokens cannot be exited."),(0,l.kt)("p",null,"If ",(0,l.kt)("inlineCode",{parentName:"p"},"toInternalBalance")," is true, the tokens will be deposited to ",(0,l.kt)("inlineCode",{parentName:"p"},"recipient"),"'s Internal Balance. Otherwise,\nan ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\ndo so will trigger a revert."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"minAmountsOut")," is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\n",(0,l.kt)("inlineCode",{parentName:"p"},"tokens")," array. This array must match the Pool's registered tokens."),(0,l.kt)("p",null,"This causes the Vault to call the ",(0,l.kt)("inlineCode",{parentName:"p"},"IBasePool.onExitPool")," hook on the Pool's contract, where Pools implement\ntheir own custom logic. This typically requires additional information from the user (such as the expected number\nof Pool shares to return). This can be encoded in the ",(0,l.kt)("inlineCode",{parentName:"p"},"userData")," argument, which is ignored by the Vault and\npassed directly to the Pool's contract."),(0,l.kt)("p",null,"Emits a ",(0,l.kt)("inlineCode",{parentName:"p"},"PoolBalanceChanged")," event."),(0,l.kt)("h4",{id:"parameters-11"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"poolId")),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes32"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"sender")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"recipient")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address payable"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"request")),(0,l.kt)("td",{parentName:"tr",align:"left"},"struct IVault.ExitPoolRequest"),(0,l.kt)("td",{parentName:"tr",align:"left"})))),(0,l.kt)("h3",{id:"swap"},"swap"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function swap(\n    struct IVault.SingleSwap singleSwap,\n    struct IVault.FundManagement funds,\n    uint256 limit,\n    uint256 deadline\n) external returns (uint256)\n")),(0,l.kt)("p",null,"Performs a swap with a single Pool."),(0,l.kt)("p",null,"If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\ntaken from the Pool, which must be greater than or equal to ",(0,l.kt)("inlineCode",{parentName:"p"},"limit"),"."),(0,l.kt)("p",null,"If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\nsent to the Pool, which must be less than or equal to ",(0,l.kt)("inlineCode",{parentName:"p"},"limit"),"."),(0,l.kt)("p",null,"Internal Balance usage and the recipient are determined by the ",(0,l.kt)("inlineCode",{parentName:"p"},"funds")," struct."),(0,l.kt)("p",null,"Emits a ",(0,l.kt)("inlineCode",{parentName:"p"},"Swap")," event."),(0,l.kt)("h4",{id:"parameters-12"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"singleSwap")),(0,l.kt)("td",{parentName:"tr",align:"left"},"struct IVault.SingleSwap"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"funds")),(0,l.kt)("td",{parentName:"tr",align:"left"},"struct IVault.FundManagement"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"limit")),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"deadline")),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"})))),(0,l.kt)("h3",{id:"batchswap"},"batchSwap"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function batchSwap(\n    enum IVault.SwapKind kind,\n    struct IVault.BatchSwapStep[] swaps,\n    contract IAsset[] assets,\n    struct IVault.FundManagement funds,\n    int256[] limits,\n    uint256 deadline\n) external returns (int256[])\n")),(0,l.kt)("p",null,"Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\nthe amount of tokens sent to or received from the Pool, depending on the ",(0,l.kt)("inlineCode",{parentName:"p"},"kind")," value."),(0,l.kt)("p",null,"Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\nVault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\nthe same index in the ",(0,l.kt)("inlineCode",{parentName:"p"},"assets")," array."),(0,l.kt)("p",null,"Swaps are executed sequentially, in the order specified by the ",(0,l.kt)("inlineCode",{parentName:"p"},"swaps")," array. Each array element describes a\nPool, the token to be sent to this Pool, the token to receive from it, and an amount that is either ",(0,l.kt)("inlineCode",{parentName:"p"},"amountIn")," or\n",(0,l.kt)("inlineCode",{parentName:"p"},"amountOut")," depending on the swap kind."),(0,l.kt)("p",null,"Multihop swaps can be executed by passing an ",(0,l.kt)("inlineCode",{parentName:"p"},"amount")," value of zero for a swap. This will cause the amount in/out\nof the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\nthe previous swap's ",(0,l.kt)("inlineCode",{parentName:"p"},"tokenOut"),". For a 'given out' swap, ",(0,l.kt)("inlineCode",{parentName:"p"},"tokenOut")," must equal the previous swap's ",(0,l.kt)("inlineCode",{parentName:"p"},"tokenIn"),"."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"assets")," array contains the addresses of all assets involved in the swaps. These are either token addresses,\nor the IAsset sentinel value for ETH (the zero address). Each entry in the ",(0,l.kt)("inlineCode",{parentName:"p"},"swaps")," array specifies tokens in and\nout by referencing an index in ",(0,l.kt)("inlineCode",{parentName:"p"},"assets"),". Note that Pools never interact with ETH directly: it will be wrapped to\nor unwrapped from WETH by the Vault."),(0,l.kt)("p",null,"Internal Balance usage, sender, and recipient are determined by the ",(0,l.kt)("inlineCode",{parentName:"p"},"funds")," struct. The ",(0,l.kt)("inlineCode",{parentName:"p"},"limits")," array specifies\nthe minimum or maximum amount of each token the vault is allowed to transfer."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"batchSwap")," can be used to make a single swap, like ",(0,l.kt)("inlineCode",{parentName:"p"},"swap")," does, but doing so requires more gas than the\nequivalent ",(0,l.kt)("inlineCode",{parentName:"p"},"swap")," call."),(0,l.kt)("p",null,"Emits ",(0,l.kt)("inlineCode",{parentName:"p"},"Swap")," events."),(0,l.kt)("h4",{id:"parameters-13"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"kind")),(0,l.kt)("td",{parentName:"tr",align:"left"},"enum IVault.SwapKind"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"swaps")),(0,l.kt)("td",{parentName:"tr",align:"left"},"struct IVault.BatchSwapStep[]"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"assets")),(0,l.kt)("td",{parentName:"tr",align:"left"},"contract IAsset[]"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"funds")),(0,l.kt)("td",{parentName:"tr",align:"left"},"struct IVault.FundManagement"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"limits")),(0,l.kt)("td",{parentName:"tr",align:"left"},"int256[]"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"deadline")),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"})))),(0,l.kt)("h3",{id:"querybatchswap"},"queryBatchSwap"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function queryBatchSwap(\n    enum IVault.SwapKind kind,\n    struct IVault.BatchSwapStep[] swaps,\n    contract IAsset[] assets,\n    struct IVault.FundManagement funds\n) external returns (int256[] assetDeltas)\n")),(0,l.kt)("p",null,"Simulates a call to ",(0,l.kt)("inlineCode",{parentName:"p"},"batchSwap"),", returning an array of Vault asset deltas. Calls to ",(0,l.kt)("inlineCode",{parentName:"p"},"swap")," cannot be\nsimulated directly, but an equivalent ",(0,l.kt)("inlineCode",{parentName:"p"},"batchSwap")," call can and will yield the exact same result."),(0,l.kt)("p",null,"Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\nthe Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\nreceives are the same that an equivalent ",(0,l.kt)("inlineCode",{parentName:"p"},"batchSwap")," call would receive."),(0,l.kt)("p",null,"Unlike ",(0,l.kt)("inlineCode",{parentName:"p"},"batchSwap"),", this function performs no checks on the sender or recipient field in the ",(0,l.kt)("inlineCode",{parentName:"p"},"funds")," struct.\nThis makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\napprove them for the Vault, or even know a user's address."),(0,l.kt)("p",null,"Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\neth_call instead of eth_sendTransaction."),(0,l.kt)("h4",{id:"parameters-14"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"kind")),(0,l.kt)("td",{parentName:"tr",align:"left"},"enum IVault.SwapKind"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"swaps")),(0,l.kt)("td",{parentName:"tr",align:"left"},"struct IVault.BatchSwapStep[]"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"assets")),(0,l.kt)("td",{parentName:"tr",align:"left"},"contract IAsset[]"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"funds")),(0,l.kt)("td",{parentName:"tr",align:"left"},"struct IVault.FundManagement"),(0,l.kt)("td",{parentName:"tr",align:"left"})))),(0,l.kt)("h3",{id:"managepoolbalance"},"managePoolBalance"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function managePoolBalance(\n    struct IVault.PoolBalanceOp[] ops\n) external\n")),(0,l.kt)("p",null,"Performs a set of Pool balance operations, which may be either withdrawals, deposits or updates."),(0,l.kt)("p",null,"Pool Balance management features batching, which means a single contract call can be used to perform multiple\noperations of different kinds, with different Pools and tokens, at once."),(0,l.kt)("p",null,"For each operation, the caller must be registered as the Asset Manager for ",(0,l.kt)("inlineCode",{parentName:"p"},"token")," in ",(0,l.kt)("inlineCode",{parentName:"p"},"poolId"),"."),(0,l.kt)("h4",{id:"parameters-15"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"ops")),(0,l.kt)("td",{parentName:"tr",align:"left"},"struct IVault.PoolBalanceOp[]"),(0,l.kt)("td",{parentName:"tr",align:"left"})))),(0,l.kt)("h3",{id:"setpaused"},"setPaused"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"function setPaused(\n    bool paused\n) external\n")),(0,l.kt)("p",null,"Safety mechanism to pause most Vault operations in the event of an emergency - typically detection of an\nerror in some part of the system."),(0,l.kt)("p",null,"The Vault can only be paused during an initial time period, after which pausing is forever disabled."),(0,l.kt)("p",null,"While the contract is paused, the following features are disabled:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"depositing and transferring internal balance"),(0,l.kt)("li",{parentName:"ul"},"transferring external balance (using the Vault's allowance)"),(0,l.kt)("li",{parentName:"ul"},"swaps"),(0,l.kt)("li",{parentName:"ul"},"joining Pools"),(0,l.kt)("li",{parentName:"ul"},"Asset Manager interactions")),(0,l.kt)("p",null,"Internal Balance can still be withdrawn, and Pools exited."),(0,l.kt)("h4",{id:"parameters-16"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"paused")),(0,l.kt)("td",{parentName:"tr",align:"left"},"bool"),(0,l.kt)("td",{parentName:"tr",align:"left"})))),(0,l.kt)("h2",{id:"events"},"Events"),(0,l.kt)("h3",{id:"relayerapprovalchanged"},"RelayerApprovalChanged"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"event RelayerApprovalChanged(\n    address relayer,\n    address sender,\n    bool approved\n)\n")),(0,l.kt)("p",null,"Emitted every time a relayer is approved or disapproved by ",(0,l.kt)("inlineCode",{parentName:"p"},"setRelayerApproval"),"."),(0,l.kt)("h4",{id:"parameters-17"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"relayer")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"sender")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"approved")),(0,l.kt)("td",{parentName:"tr",align:"left"},"bool"),(0,l.kt)("td",{parentName:"tr",align:"left"})))),(0,l.kt)("h3",{id:"internalbalancechanged"},"InternalBalanceChanged"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"event InternalBalanceChanged(\n    address user,\n    contract IERC20 token,\n    int256 delta\n)\n")),(0,l.kt)("p",null,"Emitted when a user's Internal Balance changes, either from calls to ",(0,l.kt)("inlineCode",{parentName:"p"},"manageUserBalance"),", or through\ninteracting with Pools using Internal Balance."),(0,l.kt)("p",null,"Because Internal Balance works exclusively with ERC20 tokens, ETH deposits and withdrawals will use the WETH\naddress."),(0,l.kt)("h4",{id:"parameters-18"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"user")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"token")),(0,l.kt)("td",{parentName:"tr",align:"left"},"contract IERC20"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"delta")),(0,l.kt)("td",{parentName:"tr",align:"left"},"int256"),(0,l.kt)("td",{parentName:"tr",align:"left"})))),(0,l.kt)("h3",{id:"externalbalancetransfer"},"ExternalBalanceTransfer"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"event ExternalBalanceTransfer(\n    contract IERC20 token,\n    address sender,\n    address recipient,\n    uint256 amount\n)\n")),(0,l.kt)("p",null,"Emitted when a user's Vault ERC20 allowance is used by the Vault to transfer tokens to an external account."),(0,l.kt)("h4",{id:"parameters-19"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"token")),(0,l.kt)("td",{parentName:"tr",align:"left"},"contract IERC20"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"sender")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"recipient")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"amount")),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"})))),(0,l.kt)("h3",{id:"poolregistered"},"PoolRegistered"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"event PoolRegistered(\n    bytes32 poolId,\n    address poolAddress,\n    enum IVault.PoolSpecialization specialization\n)\n")),(0,l.kt)("p",null,"Emitted when a Pool is registered by calling ",(0,l.kt)("inlineCode",{parentName:"p"},"registerPool"),"."),(0,l.kt)("h4",{id:"parameters-20"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"poolId")),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes32"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"poolAddress")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"specialization")),(0,l.kt)("td",{parentName:"tr",align:"left"},"enum IVault.PoolSpecialization"),(0,l.kt)("td",{parentName:"tr",align:"left"})))),(0,l.kt)("h3",{id:"tokensregistered"},"TokensRegistered"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"event TokensRegistered(\n    bytes32 poolId,\n    contract IERC20[] tokens,\n    address[] assetManagers\n)\n")),(0,l.kt)("p",null,"Emitted when a Pool registers tokens by calling ",(0,l.kt)("inlineCode",{parentName:"p"},"registerTokens"),"."),(0,l.kt)("h4",{id:"parameters-21"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"poolId")),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes32"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"tokens")),(0,l.kt)("td",{parentName:"tr",align:"left"},"contract IERC20[]"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"assetManagers")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address[]"),(0,l.kt)("td",{parentName:"tr",align:"left"})))),(0,l.kt)("h3",{id:"tokensderegistered"},"TokensDeregistered"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"event TokensDeregistered(\n    bytes32 poolId,\n    contract IERC20[] tokens\n)\n")),(0,l.kt)("p",null,"Emitted when a Pool deregisters tokens by calling ",(0,l.kt)("inlineCode",{parentName:"p"},"deregisterTokens"),"."),(0,l.kt)("h4",{id:"parameters-22"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"poolId")),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes32"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"tokens")),(0,l.kt)("td",{parentName:"tr",align:"left"},"contract IERC20[]"),(0,l.kt)("td",{parentName:"tr",align:"left"})))),(0,l.kt)("h3",{id:"poolbalancechanged"},"PoolBalanceChanged"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"event PoolBalanceChanged(\n    bytes32 poolId,\n    address liquidityProvider,\n    contract IERC20[] tokens,\n    int256[] deltas,\n    uint256[] protocolFeeAmounts\n)\n")),(0,l.kt)("p",null,"Emitted when a user joins or exits a Pool by calling ",(0,l.kt)("inlineCode",{parentName:"p"},"joinPool")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"exitPool"),", respectively."),(0,l.kt)("h4",{id:"parameters-23"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"poolId")),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes32"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"liquidityProvider")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"tokens")),(0,l.kt)("td",{parentName:"tr",align:"left"},"contract IERC20[]"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"deltas")),(0,l.kt)("td",{parentName:"tr",align:"left"},"int256[]"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"protocolFeeAmounts")),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256[]"),(0,l.kt)("td",{parentName:"tr",align:"left"})))),(0,l.kt)("h3",{id:"swap-1"},"Swap"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"event Swap(\n    bytes32 poolId,\n    contract IERC20 tokenIn,\n    contract IERC20 tokenOut,\n    uint256 amountIn,\n    uint256 amountOut\n)\n")),(0,l.kt)("p",null,"Emitted for each individual swap performed by ",(0,l.kt)("inlineCode",{parentName:"p"},"swap")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"batchSwap"),"."),(0,l.kt)("h4",{id:"parameters-24"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"poolId")),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes32"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"tokenIn")),(0,l.kt)("td",{parentName:"tr",align:"left"},"contract IERC20"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"tokenOut")),(0,l.kt)("td",{parentName:"tr",align:"left"},"contract IERC20"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"amountIn")),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"amountOut")),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,l.kt)("td",{parentName:"tr",align:"left"})))),(0,l.kt)("h3",{id:"poolbalancemanaged"},"PoolBalanceManaged"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"event PoolBalanceManaged(\n    bytes32 poolId,\n    address assetManager,\n    contract IERC20 token,\n    int256 cashDelta,\n    int256 managedDelta\n)\n")),(0,l.kt)("p",null,"Emitted when a Pool's token Asset Manager alters its balance via ",(0,l.kt)("inlineCode",{parentName:"p"},"managePoolBalance"),"."),(0,l.kt)("h4",{id:"parameters-25"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"poolId")),(0,l.kt)("td",{parentName:"tr",align:"left"},"bytes32"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"assetManager")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"token")),(0,l.kt)("td",{parentName:"tr",align:"left"},"contract IERC20"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"cashDelta")),(0,l.kt)("td",{parentName:"tr",align:"left"},"int256"),(0,l.kt)("td",{parentName:"tr",align:"left"})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"managedDelta")),(0,l.kt)("td",{parentName:"tr",align:"left"},"int256"),(0,l.kt)("td",{parentName:"tr",align:"left"})))))}N.isMDXComponent=!0}}]);